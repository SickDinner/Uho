<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÆ CLEAN KENNEY RPG üéÆ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000011;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        h1 {
            color: #ffdd00;
            text-shadow: 2px 2px 0px #ff0044, 4px 4px 8px #000000;
            margin: 8px 0;
            font-size: 1.8em;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .game-container {
            position: relative;
            border: 6px solid #4a90e2;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            box-shadow: 
                0 0 40px rgba(74, 144, 226, 0.6),
                inset 0 0 20px rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            background: linear-gradient(45deg, #1a3d5c, #2a5d8c);
        }

        .ui-overlay {
            position: absolute;
            top: 12px;
            left: 12px;
            background: linear-gradient(135deg, rgba(0, 0, 40, 0.95), rgba(20, 20, 60, 0.95));
            border: 3px solid #4a90e2;
            border-radius: 8px;
            padding: 12px;
            font-size: 14px;
            min-width: 180px;
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.4);
        }

        .health-bar {
            width: 120px;
            height: 12px;
            background: linear-gradient(90deg, #330000, #440000);
            border: 2px solid #ffffff;
            border-radius: 6px;
            margin: 6px 0;
            position: relative;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0044, #ff6600, #ffaa00);
            transition: width 0.5s ease;
            box-shadow: inset 0 0 8px rgba(255, 255, 255, 0.3);
        }

        .subtitle {
            color: #4a90e2;
            font-size: 0.9em;
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 1px 1px 2px #000000;
        }

        /* SNES-style scanlines */
        .game-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.1) 2px,
                rgba(0, 0, 0, 0.1) 4px
            );
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <h1>üéÆ Kenney RPG Adventure üéÆ</h1>
    <div class="subtitle">Real Kenney Assets ‚Ä¢ Smooth Movement ‚Ä¢ Clean Interface</div>

    <div class="game-container">
        <canvas id="gameCanvas" width="960" height="640"></canvas>
        
        <div class="ui-overlay">
            <div style="color: #ffdd00; font-weight: bold;">HERO STATUS</div>
            <div>‚ù§Ô∏è HP: <span id="playerHP">100</span>/100</div>
            <div class="health-bar">
                <div class="health-fill" id="healthFill" style="width: 100%"></div>
            </div>
            <div>üí∞ Gold: <span id="playerGold">0</span></div>
            <div>‚≠ê XP: <span id="playerXP">0</span></div>
            <div>üó∫Ô∏è Area: <span id="currentArea">Forest</span></div>
        </div>
    </div>

    <script>
        console.log('üéÆ Starting Clean Kenney RPG...');

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Disable image smoothing for crisp pixel art
        ctx.imageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;
        ctx.msImageSmoothingEnabled = false;

        // Game constants
        const WORLD_SIZE = 2000;
        const BASE_SPEED = 3;
        const RUN_MULTIPLIER = 2.2;
        const ROTATION_SPEED = 0.08;
        const MIN_ZOOM = 0.5;
        const MAX_ZOOM = 2.5;
        const ZOOM_SPEED = 0.02;

        // Game state
        let gameState = {
            player: {
                x: WORLD_SIZE / 2,
                y: WORLD_SIZE / 2,
                angle: 0,
                velocity: { x: 0, y: 0 },
                speed: 0,
                hp: 100,
                maxHP: 100,
                gold: 0,
                xp: 0,
                isRunning: false,
                size: 32
            },
            camera: {
                x: WORLD_SIZE / 2,
                y: WORLD_SIZE / 2,
                zoom: 1.0,
                targetZoom: 1.0,
                shake: { intensity: 0 }
            },
            world: {
                objects: [],
                particles: [],
                background: []
            },
            input: {
                keys: {},
                mouse: { x: 0, y: 0, down: false }
            },
            assets: {
                loaded: false,
                sprites: {}
            },
            frame: 0,
            lastTime: 0
        };

        // Load Kenney sprites from your local files
        function loadKenneyAssets() {
            console.log('üé® Loading Kenney assets...');
            
            const assetPaths = {
                // Character sprites
                'player': 'assets/sprites/16bit/zip/PNG/Characters/man.png',
                'player_walk1': 'assets/sprites/16bit/zip/PNG/Characters/man_walk1.png',
                'player_walk2': 'assets/sprites/16bit/zip/PNG/Characters/man_walk2.png',
                
                // Environment sprites
                'tree': 'assets/sprites/16bit/zip/PNG/Default/tree.png',
                'bush1': 'assets/sprites/16bit/zip/PNG/Default/bush1.png',
                'bush2': 'assets/sprites/16bit/zip/PNG/Default/bush2.png',
                'house1': 'assets/sprites/16bit/zip/PNG/Default/house1.png',
                'house2': 'assets/sprites/16bit/zip/PNG/Default/house2.png',
                'castle': 'assets/sprites/16bit/zip/PNG/Default/castleSmall.png',
                'tower': 'assets/sprites/16bit/zip/PNG/Default/tower.png',
                'fence': 'assets/sprites/16bit/zip/PNG/Default/fence.png',
                
                // Natural elements
                'cactus1': 'assets/sprites/16bit/zip/PNG/Default/cactus1.png',
                'cactus2': 'assets/sprites/16bit/zip/PNG/Default/cactus2.png',
                'pyramid': 'assets/sprites/16bit/zip/PNG/Default/pyramid.png',
                
                // Background elements
                'grass_bg': 'assets/sprites/16bit/zip/PNG/Backgrounds/colored_grass.png',
                'desert_bg': 'assets/sprites/16bit/zip/PNG/Backgrounds/colored_desert.png'
            };

            let loadedCount = 0;
            const totalAssets = Object.keys(assetPaths).length;

            // Create fallback sprites if files don't load
            createFallbackSprites();

            for (const [key, path] of Object.entries(assetPaths)) {
                const img = new Image();
                img.onload = () => {
                    gameState.assets.sprites[key] = img;
                    loadedCount++;
                    console.log(`üì∑ Loaded: ${key} (${loadedCount}/${totalAssets})`);
                    
                    if (loadedCount === totalAssets) {
                        gameState.assets.loaded = true;
                        console.log('‚úÖ All Kenney assets loaded!');
                    }
                };
                img.onerror = () => {
                    console.warn(`‚ö†Ô∏è Failed to load: ${path}, using fallback`);
                    loadedCount++;
                    if (loadedCount === totalAssets) {
                        gameState.assets.loaded = true;
                        console.log('‚úÖ Assets loaded with fallbacks!');
                    }
                };
                img.src = path;
            }
        }

        // Create fallback sprites (simple colored rectangles) 
        function createFallbackSprites() {
            const fallbacks = {
                'player': { color: '#4169E1', width: 32, height: 32 },
                'tree': { color: '#228B22', width: 48, height: 64 },
                'bush1': { color: '#32CD32', width: 32, height: 24 },
                'bush2': { color: '#90EE90', width: 32, height: 24 },
                'house1': { color: '#8B4513', width: 64, height: 64 },
                'house2': { color: '#CD853F', width: 64, height: 64 },
                'castle': { color: '#696969', width: 96, height: 96 },
                'tower': { color: '#A9A9A9', width: 48, height: 96 },
                'fence': { color: '#DEB887', width: 32, height: 16 },
                'cactus1': { color: '#2E8B57', width: 24, height: 48 },
                'cactus2': { color: '#228B22', width: 32, height: 56 },
                'pyramid': { color: '#DAA520', width: 80, height: 64 }
            };

            for (const [key, props] of Object.entries(fallbacks)) {
                const canvas = document.createElement('canvas');
                canvas.width = props.width;
                canvas.height = props.height;
                const ctx = canvas.getContext('2d');
                
                // Draw simple colored shape
                ctx.fillStyle = props.color;
                ctx.fillRect(0, 0, props.width, props.height);
                
                // Add outline
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.strokeRect(1, 1, props.width - 2, props.height - 2);
                
                gameState.assets.sprites[key] = canvas;
            }
        }

        // Generate Kenney-style world with real assets
        function generateWorld() {
            console.log('üåç Generating world with Kenney assets...');
            
            gameState.world.objects = [];
            gameState.world.background = [];
            
            // Create background pattern
            for (let x = 0; x < WORLD_SIZE; x += 64) {
                for (let y = 0; y < WORLD_SIZE; y += 64) {
                    let bgType = 'grass';
                    if (Math.random() < 0.2) bgType = 'desert';
                    
                    gameState.world.background.push({
                        x: x, y: y, type: bgType, size: 64
                    });
                }
            }
            
            // Add environmental objects
            const objectTypes = [
                { type: 'tree', count: 80, minDistance: 100 },
                { type: 'bush1', count: 60, minDistance: 50 },
                { type: 'bush2', count: 40, minDistance: 50 },
                { type: 'house1', count: 15, minDistance: 200 },
                { type: 'house2', count: 10, minDistance: 200 },
                { type: 'castle', count: 3, minDistance: 400 },
                { type: 'tower', count: 8, minDistance: 300 },
                { type: 'fence', count: 30, minDistance: 100 },
                { type: 'cactus1', count: 25, minDistance: 80 },
                { type: 'cactus2', count: 20, minDistance: 80 },
                { type: 'pyramid', count: 5, minDistance: 350 }
            ];

            objectTypes.forEach(objDef => {
                for (let i = 0; i < objDef.count; i++) {
                    const x = Math.random() * WORLD_SIZE;
                    const y = Math.random() * WORLD_SIZE;
                    const distance = Math.sqrt(
                        Math.pow(x - gameState.player.x, 2) + 
                        Math.pow(y - gameState.player.y, 2)
                    );
                    
                    if (distance > objDef.minDistance) {
                        gameState.world.objects.push({
                            x: x, y: y, 
                            type: objDef.type, 
                            size: getSpriteSize(objDef.type),
                            solid: isSolid(objDef.type),
                            collectible: false
                        });
                    }
                }
            });

            // Add collectible coins/gems scattered around
            for (let i = 0; i < 40; i++) {
                const x = Math.random() * WORLD_SIZE;
                const y = Math.random() * WORLD_SIZE;
                gameState.world.objects.push({
                    x: x, y: y,
                    type: Math.random() < 0.5 ? 'coin' : 'gem',
                    size: 16,
                    collectible: true,
                    value: Math.random() * 25 + 5,
                    floatOffset: Math.random() * Math.PI * 2
                });
            }
            
            console.log(`‚úÖ World generated: ${gameState.world.objects.length} objects`);
        }

        function getSpriteSize(type) {
            const sizes = {
                'tree': 48, 'bush1': 32, 'bush2': 32, 'house1': 64, 'house2': 64,
                'castle': 96, 'tower': 48, 'fence': 32, 'cactus1': 24, 'cactus2': 32, 
                'pyramid': 80, 'coin': 16, 'gem': 16
            };
            return sizes[type] || 32;
        }

        function isSolid(type) {
            return ['tree', 'house1', 'house2', 'castle', 'tower', 'cactus1', 'cactus2', 'pyramid'].includes(type);
        }

        // Smooth input handling
        function handleInput(deltaTime) {
            const input = gameState.input;
            const player = gameState.player;
            
            player.velocity.x = 0;
            player.velocity.y = 0;
            player.isRunning = input.keys['ShiftLeft'] || input.keys['ShiftRight'];
            
            const speed = player.isRunning ? BASE_SPEED * RUN_MULTIPLIER : BASE_SPEED;
            
            // Smooth WASD movement
            if (input.keys['KeyW']) player.velocity.y -= speed;
            if (input.keys['KeyS']) player.velocity.y += speed;
            if (input.keys['KeyA']) player.velocity.x -= speed;
            if (input.keys['KeyD']) player.velocity.x += speed;
            
            // Normalize diagonal movement
            const magnitude = Math.sqrt(player.velocity.x * player.velocity.x + player.velocity.y * player.velocity.y);
            if (magnitude > 0) {
                player.velocity.x = (player.velocity.x / magnitude) * speed;
                player.velocity.y = (player.velocity.y / magnitude) * speed;
                
                // Smooth 360¬∞ rotation toward movement direction
                const targetAngle = Math.atan2(player.velocity.y, player.velocity.x);
                let angleDiff = targetAngle - player.angle;
                
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                
                player.angle += angleDiff * ROTATION_SPEED;
            }
            
            // Zoom controls
            if (input.keys['KeyQ']) gameState.camera.targetZoom = Math.max(MIN_ZOOM, gameState.camera.targetZoom - ZOOM_SPEED);
            if (input.keys['KeyE']) gameState.camera.targetZoom = Math.min(MAX_ZOOM, gameState.camera.targetZoom + ZOOM_SPEED);
            
            // Mouse look
            if (input.mouse.down) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const mouseAngle = Math.atan2(input.mouse.y - centerY, input.mouse.x - centerX);
                player.angle = mouseAngle;
            }
        }

        // Update game physics
        function updateGame(deltaTime) {
            const player = gameState.player;
            
            player.x += player.velocity.x * (deltaTime / 16.67);
            player.y += player.velocity.y * (deltaTime / 16.67);
            
            player.x = Math.max(player.size, Math.min(WORLD_SIZE - player.size, player.x));
            player.y = Math.max(player.size, Math.min(WORLD_SIZE - player.size, player.y));
            
            // Smooth camera follow
            const cameraSmooth = 0.1;
            gameState.camera.x += (player.x - gameState.camera.x) * cameraSmooth;
            gameState.camera.y += (player.y - gameState.camera.y) * cameraSmooth;
            
            gameState.camera.zoom += (gameState.camera.targetZoom - gameState.camera.zoom) * 0.1;
            
            checkCollisions();
            updateParticles(deltaTime);
        }

        function checkCollisions() {
            const player = gameState.player;
            
            gameState.world.objects.forEach((obj, index) => {
                const distance = Math.sqrt(
                    Math.pow(obj.x - player.x, 2) + 
                    Math.pow(obj.y - player.y, 2)
                );
                
                if (distance < (obj.size + player.size) / 2) {
                    if (obj.collectible) {
                        if (obj.type === 'coin') gameState.player.gold += Math.floor(obj.value);
                        else if (obj.type === 'gem') gameState.player.xp += Math.floor(obj.value);
                        
                        createParticleEffect(obj.x, obj.y, obj.type);
                        gameState.world.objects.splice(index, 1);
                        console.log(`üíé Collected ${obj.type}!`);
                    } else if (obj.solid) {
                        // Push back collision
                        const pushX = (player.x - obj.x) / distance;
                        const pushY = (player.y - obj.y) / distance;
                        player.x = obj.x + pushX * ((obj.size + player.size) / 2);
                        player.y = obj.y + pushY * ((obj.size + player.size) / 2);
                    }
                }
            });
        }

        function createParticleEffect(x, y, type) {
            const colors = {
                'coin': '#FFD700',
                'gem': '#9932CC'
            };
            
            for (let i = 0; i < 8; i++) {
                gameState.world.particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 1.0,
                    color: colors[type] || '#FFFFFF',
                    size: Math.random() * 4 + 2
                });
            }
        }

        function updateParticles(deltaTime) {
            gameState.world.particles.forEach((particle, index) => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += 0.1;
                particle.life -= deltaTime / 1000;
                
                if (particle.life <= 0) {
                    gameState.world.particles.splice(index, 1);
                }
            });
        }

        // Render game
        function render() {
            const camera = gameState.camera;
            const player = gameState.player;
            
            // Clear with grass-like background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.7, '#98FB98');
            gradient.addColorStop(1, '#228B22');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            
            // Camera transformations
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(-camera.x, -camera.y);
            
            // Camera shake
            if (camera.shake.intensity > 0) {
                ctx.translate(
                    (Math.random() - 0.5) * camera.shake.intensity,
                    (Math.random() - 0.5) * camera.shake.intensity
                );
                camera.shake.intensity *= 0.9;
            }
            
            renderBackground();
            renderWorldObjects();
            renderParticles();
            renderPlayer();
            
            ctx.restore();
            
            renderUI();
        }

        function renderBackground() {
            // Render tiled background
            gameState.world.background.forEach(tile => {
                const sprite = gameState.assets.sprites[tile.type + '_bg'];
                if (sprite) {
                    ctx.drawImage(sprite, tile.x, tile.y, tile.size, tile.size);
                } else {
                    // Fallback colored tile
                    ctx.fillStyle = tile.type === 'desert' ? '#DEB887' : '#32CD32';
                    ctx.fillRect(tile.x, tile.y, tile.size, tile.size);
                }
            });
        }

        function renderWorldObjects() {
            const camera = gameState.camera;
            
            gameState.world.objects.forEach(obj => {
                // Cull off-screen objects
                if (obj.x < camera.x - canvas.width || obj.x > camera.x + canvas.width ||
                    obj.y < camera.y - canvas.height || obj.y > camera.y + canvas.height) {
                    return;
                }
                
                let offsetY = 0;
                
                // Floating animation for collectibles
                if (obj.collectible) {
                    offsetY = Math.sin(gameState.frame * 0.1 + (obj.floatOffset || 0)) * 3;
                    
                    // Simple coin/gem rendering
                    ctx.fillStyle = obj.type === 'coin' ? '#FFD700' : '#9932CC';
                    ctx.fillRect(
                        obj.x - obj.size/2, 
                        obj.y - obj.size/2 + offsetY, 
                        obj.size, obj.size
                    );
                    return;
                }
                
                // Render sprite or fallback
                const sprite = gameState.assets.sprites[obj.type];
                if (sprite && sprite.width) {
                    ctx.drawImage(
                        sprite, 
                        obj.x - obj.size/2, 
                        obj.y - obj.size/2, 
                        obj.size, obj.size
                    );
                } else {
                    // Fallback colored rect
                    ctx.fillStyle = getSpriteColor(obj.type);
                    ctx.fillRect(
                        obj.x - obj.size/2, 
                        obj.y - obj.size/2, 
                        obj.size, obj.size
                    );
                }
            });
        }

        function getSpriteColor(type) {
            const colors = {
                'tree': '#228B22', 'bush1': '#32CD32', 'bush2': '#90EE90',
                'house1': '#8B4513', 'house2': '#CD853F', 'castle': '#696969',
                'tower': '#A9A9A9', 'fence': '#DEB887', 'cactus1': '#2E8B57',
                'cactus2': '#228B22', 'pyramid': '#DAA520'
            };
            return colors[type] || '#666666';
        }

        function renderParticles() {
            gameState.world.particles.forEach(particle => {
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.fillRect(
                    particle.x - particle.size/2, 
                    particle.y - particle.size/2, 
                    particle.size, particle.size
                );
                ctx.globalAlpha = 1.0;
            });
        }

        function renderPlayer() {
            const player = gameState.player;
            
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);
            
            // Try to use loaded character sprite, fallback to simple rect
            const playerSprite = gameState.assets.sprites['player'];
            if (playerSprite && playerSprite.width) {
                ctx.drawImage(
                    playerSprite, 
                    -player.size/2, -player.size/2, 
                    player.size, player.size
                );
            } else {
                // Simple blue square as fallback
                ctx.fillStyle = '#4169E1';
                ctx.fillRect(-player.size/2, -player.size/2, player.size, player.size);
                
                // Direction indicator
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(player.size/4, -2, player.size/4, 4);
            }
            
            ctx.restore();
        }

        function renderUI() {
            document.getElementById('playerHP').textContent = Math.floor(gameState.player.hp);
            document.getElementById('playerGold').textContent = gameState.player.gold;
            document.getElementById('playerXP').textContent = gameState.player.xp;
            
            const healthPercent = (gameState.player.hp / gameState.player.maxHP) * 100;
            document.getElementById('healthFill').style.width = healthPercent + '%';
        }

        // Game loop
        function gameLoop(currentTime) {
            const deltaTime = currentTime - gameState.lastTime;
            gameState.lastTime = currentTime;
            gameState.frame++;
            
            handleInput(deltaTime);
            updateGame(deltaTime);
            render();
            
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            gameState.input.keys[e.code] = true;
            
            if (e.code === 'Space') {
                e.preventDefault();
                console.log('‚ö° Action!');
                gameState.camera.shake.intensity = 10;
            }
        });

        document.addEventListener('keyup', (e) => {
            gameState.input.keys[e.code] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            gameState.input.mouse.x = e.clientX - rect.left;
            gameState.input.mouse.y = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', (e) => {
            gameState.input.mouse.down = true;
        });

        canvas.addEventListener('mouseup', (e) => {
            gameState.input.mouse.down = false;
        });

        // Initialize game
        function initGame() {
            console.log('üéÆ Initializing Clean Kenney RPG...');
            loadKenneyAssets();
            generateWorld();
            console.log('‚úÖ Game initialized! Starting gameplay...');
            requestAnimationFrame(gameLoop);
        }

        // Start the game
        initGame();
    </script>
</body>
</html>